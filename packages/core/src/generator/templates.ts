import type { RouteSpec } from "../spec/schema";

export function generateApiHandler(route: RouteSpec): string {
  // contractModule + slotModuleì´ ìˆìœ¼ë©´ contract ê²€ì¦ ë²„ì „ ìƒì„±
  if (route.contractModule && route.slotModule) {
    return generateApiHandlerWithContract(route);
  }

  // slotModuleë§Œ ìˆìœ¼ë©´ slotì„ í˜¸ì¶œí•˜ëŠ” ë²„ì „ ìƒì„±
  if (route.slotModule) {
    return generateApiHandlerWithSlot(route);
  }

  return `// Generated by Mandu - DO NOT EDIT DIRECTLY
// Route ID: ${route.id}
// Pattern: ${route.pattern}

import type { Request } from "bun";

export default function handler(req: Request, params: Record<string, string>): Response {
  return Response.json({
    status: "ok",
    routeId: "${route.id}",
    pattern: "${route.pattern}",
    timestamp: new Date().toISOString(),
  });
}
`;
}

export function generateApiHandlerWithSlot(route: RouteSpec): string {
  const slotImportPath = computeSlotImportPath(route.slotModule!, "apps/server/generated/routes");

  return `// Generated by Mandu - DO NOT EDIT DIRECTLY
// Route ID: ${route.id}
// Pattern: ${route.pattern}
// Slot Module: ${route.slotModule}

import type { Request } from "bun";
import filling from "${slotImportPath}";

export default async function handler(
  req: Request,
  params: Record<string, string>
): Promise<Response> {
  return filling.handle(req, params);
}
`;
}

export function generateApiHandlerWithContract(route: RouteSpec): string {
  const slotImportPath = computeSlotImportPath(route.slotModule!, "apps/server/generated/routes");
  const contractImportPath = computeSlotImportPath(route.contractModule!, "apps/server/generated/routes");

  return `// Generated by Mandu - DO NOT EDIT DIRECTLY
// Route ID: ${route.id}
// Pattern: ${route.pattern}
// Contract Module: ${route.contractModule}
// Slot Module: ${route.slotModule}

import type { Request } from "bun";
import { ContractValidator, formatValidationErrors } from "@mandujs/core";
import contract from "${contractImportPath}";
import filling from "${slotImportPath}";

const validator = new ContractValidator(contract);
const isDev = process.env.NODE_ENV !== "production";

export default async function handler(
  req: Request,
  params: Record<string, string>
): Promise<Response> {
  const method = req.method;

  // 1. Request Validation
  const reqValidation = await validator.validateRequest(req, method, params);
  if (!reqValidation.success) {
    return Response.json(
      formatValidationErrors(reqValidation.errors!),
      { status: 400 }
    );
  }

  // 2. Execute Filling
  const response = await filling.handle(req, params, {
    routeId: "${route.id}",
    pattern: "${route.pattern}",
  });

  // 3. Response Validation (dev only)
  if (isDev && response.headers.get("content-type")?.includes("application/json")) {
    try {
      const cloned = response.clone();
      const body = await cloned.json();
      const resValidation = validator.validateResponse(body, response.status);
      if (!resValidation.success) {
        console.warn(
          "\\x1b[33m[Mandu] Contract violation in response:\\x1b[0m",
          "${route.id}",
          resValidation.errors
        );
      }
    } catch {
      // Ignore JSON parse errors for non-JSON responses
    }
  }

  return response;
}
`;
}

export function generateSlotLogic(route: RouteSpec): string {
  return `// ğŸ¥Ÿ Mandu Filling - ${route.id}
// Pattern: ${route.pattern}
// ì´ íŒŒì¼ì—ì„œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ êµ¬í˜„í•˜ì„¸ìš”.

import { Mandu } from "@mandujs/core";

export default Mandu.filling()
  // ğŸ“‹ GET ${route.pattern}
  .get((ctx) => {
    return ctx.ok({
      message: "Hello from ${route.id}!",
      timestamp: new Date().toISOString(),
    });
  })

  // â• POST ${route.pattern}
  .post(async (ctx) => {
    const body = await ctx.body();
    return ctx.created({
      message: "Created!",
      received: body,
    });
  });

// ğŸ’¡ ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ì„œë“œ:
// .get(ctx => ...)     - GET ìš”ì²­ ì²˜ë¦¬
// .post(ctx => ...)    - POST ìš”ì²­ ì²˜ë¦¬
// .put(ctx => ...)     - PUT ìš”ì²­ ì²˜ë¦¬
// .delete(ctx => ...)  - DELETE ìš”ì²­ ì²˜ë¦¬
// .guard(ctx => ...)   - ì¸ì¦/ê²€ì¦ ë¯¸ë“¤ì›¨ì–´
//
// ğŸ’¡ Context (ctx) API:
// ctx.query            - Query parameters { name: 'value' }
// ctx.params           - Path parameters { id: '123' }
// ctx.body()           - Request body (ìë™ íŒŒì‹±)
// ctx.body(zodSchema)  - Body with validation
// ctx.headers          - Request headers
// ctx.ok(data)         - 200 OK
// ctx.created(data)    - 201 Created
// ctx.error(msg)       - 400 Bad Request
// ctx.notFound(msg)    - 404 Not Found
// ctx.set(key, value)  - Guardì—ì„œ Handlerë¡œ ë°ì´í„° ì „ë‹¬
// ctx.get(key)         - Guardì—ì„œ ì„¤ì •í•œ ë°ì´í„° ì½ê¸°
`;
}

function computeSlotImportPath(slotModule: string, fromDir: string): string {
  // slotModule: "apps/server/slots/users.logic.ts"
  // fromDir: "apps/server/generated/routes"
  // result: "../../slots/users.logic"

  const slotParts = slotModule.replace(/\\/g, "/").split("/");
  const fromParts = fromDir.replace(/\\/g, "/").split("/");

  // Find common prefix length
  let commonLength = 0;
  while (
    commonLength < slotParts.length &&
    commonLength < fromParts.length &&
    slotParts[commonLength] === fromParts[commonLength]
  ) {
    commonLength++;
  }

  // Calculate relative path
  const upCount = fromParts.length - commonLength;
  const relativeParts = slotParts.slice(commonLength);
  const ups = Array(upCount).fill("..");

  let result = [...ups, ...relativeParts].join("/");

  // Remove .ts extension
  result = result.replace(/\.ts$/, "");

  return result;
}

export function generatePageComponent(route: RouteSpec): string {
  // Island-First: clientModuleì´ ìˆìœ¼ë©´ Island renderë¥¼ SSRì—ì„œ ì§ì ‘ ì‚¬ìš©
  if (route.clientModule) {
    return generatePageComponentWithIsland(route);
  }

  // slotModuleì´ ìˆìœ¼ë©´ PageHandler í˜•ì‹ìœ¼ë¡œ ìƒì„± (filling í¬í•¨)
  if (route.slotModule) {
    return generatePageHandlerWithSlot(route);
  }

  const pageName = toPascalCase(route.id);

  // slotModuleì´ ì—†ìœ¼ë©´ ê¸°ì¡´ ë°©ì‹
  return `// Generated by Mandu - DO NOT EDIT DIRECTLY
// Route ID: ${route.id}
// Pattern: ${route.pattern}

import React from "react";

interface Props {
  params: Record<string, string>;
  loaderData?: unknown;
}

export default function ${pageName}Page({ params }: Props): React.ReactElement {
  return React.createElement("div", null,
    React.createElement("h1", null, "${pageName} Page"),
    React.createElement("p", null, "Route ID: ${route.id}"),
    React.createElement("p", null, "Pattern: ${route.pattern}")
  );
}
`;
}

/**
 * Island-First Rendering: SSRì´ islandì˜ render í•¨ìˆ˜ë¥¼ ì§ì ‘ ì‚¬ìš©
 * - clientModuleì˜ definition.setup() + definition.render() í˜¸ì¶œ
 * - SSRê³¼ í´ë¼ì´ì–¸íŠ¸ê°€ ë™ì¼í•œ ë Œë”ë§ ë¡œì§ ì‚¬ìš© â†’ ë¶ˆì¼ì¹˜ êµ¬ì¡°ì  ë°©ì§€
 * - slotModule ìœ ë¬´ì— ë”°ë¼ ë‘ ê°€ì§€ ë³€í˜• ìƒì„±
 */
export function generatePageComponentWithIsland(route: RouteSpec): string {
  const pageName = toPascalCase(route.id);
  const clientImportPath = computeSlotImportPath(route.clientModule!, "apps/web/generated/routes");

  // clientModule + slotModule â†’ PageRegistration í˜•ì‹
  if (route.slotModule) {
    const slotImportPath = computeSlotImportPath(route.slotModule!, "apps/web/generated/routes");

    return `// Generated by Mandu - DO NOT EDIT DIRECTLY
// Island-First Rendering + Slot Module
// Route ID: ${route.id}
// Pattern: ${route.pattern}
// Client Module: ${route.clientModule}
// Slot Module: ${route.slotModule}

import React from "react";
import filling from "${slotImportPath}";
import islandModule from "${clientImportPath}";

interface Props {
  params: Record<string, string>;
  loaderData?: unknown;
}

function ${pageName}Page({ params, loaderData }: Props): React.ReactElement {
  const serverData = (loaderData || {}) as any;
  const setupResult = islandModule.definition.setup(serverData);
  return islandModule.definition.render(setupResult) as React.ReactElement;
}

// PageRegistration í˜•ì‹ìœ¼ë¡œ export (server.tsì˜ registerPageHandlerìš©)
export default {
  component: ${pageName}Page,
  filling: filling,
};
`;
  }

  // clientModuleë§Œ (slotModule ì—†ìŒ) â†’ default export ì»´í¬ë„ŒíŠ¸
  return `// Generated by Mandu - DO NOT EDIT DIRECTLY
// Island-First Rendering: SSRì´ island render ì§ì ‘ ì‚¬ìš©
// Route ID: ${route.id}
// Pattern: ${route.pattern}
// Client Module: ${route.clientModule}

import React from "react";
import islandModule from "${clientImportPath}";

interface Props {
  params: Record<string, string>;
  loaderData?: unknown;
}

export default function ${pageName}Page({ params, loaderData }: Props): React.ReactElement {
  const serverData = (loaderData || {}) as any;
  const setupResult = islandModule.definition.setup(serverData);
  return islandModule.definition.render(setupResult) as React.ReactElement;
}
`;
}

/**
 * slotModuleì´ ìˆëŠ” Page Routeìš© Handler ìƒì„±
 * - componentì™€ fillingì„ í•¨ê»˜ export
 * - server.tsì—ì„œ filling.executeLoader() í˜¸ì¶œ ê°€ëŠ¥
 */
export function generatePageHandlerWithSlot(route: RouteSpec): string {
  const pageName = toPascalCase(route.id);
  const slotImportPath = computeSlotImportPath(route.slotModule!, "apps/server/generated/routes");

  return `// Generated by Mandu - DO NOT EDIT DIRECTLY
// Route ID: ${route.id}
// Pattern: ${route.pattern}
// Slot Module: ${route.slotModule}

import React from "react";
import filling from "${slotImportPath}";

interface Props {
  params: Record<string, string>;
  loaderData?: unknown;
}

function ${pageName}Page({ params, loaderData }: Props): React.ReactElement {
  return React.createElement("div", null,
    React.createElement("h1", null, "${pageName} Page"),
    React.createElement("p", null, "Route ID: ${route.id}"),
    React.createElement("p", null, "Pattern: ${route.pattern}"),
    loaderData ? React.createElement("pre", null, JSON.stringify(loaderData, null, 2)) : null
  );
}

// PageRegistration í˜•ì‹ìœ¼ë¡œ export (server.tsì˜ registerPageHandlerìš©)
export default {
  component: ${pageName}Page,
  filling: filling,
};
`;
}

/**
 * Convert string to PascalCase (handles kebab-case, snake_case)
 * "todo-page" â†’ "TodoPage"
 * "user_profile" â†’ "UserProfile"
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");
}
