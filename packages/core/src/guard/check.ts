import { GUARD_RULES, FORBIDDEN_IMPORTS, type GuardViolation } from "./rules";
import { verifyLock, computeHash } from "../spec/lock";
import type { RoutesManifest } from "../spec/schema";
import type { GeneratedMap } from "../generator/generate";
import path from "path";
import fs from "fs/promises";

export interface GuardCheckResult {
  passed: boolean;
  violations: GuardViolation[];
}

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

async function readFileContent(filePath: string): Promise<string | null> {
  try {
    return await Bun.file(filePath).text();
  } catch {
    return null;
  }
}

// Rule 1: Spec hash mismatch
export async function checkSpecHashMismatch(
  manifest: RoutesManifest,
  lockPath: string
): Promise<GuardViolation | null> {
  const result = await verifyLock(lockPath, manifest);

  if (!result.valid) {
    return {
      ruleId: GUARD_RULES.SPEC_HASH_MISMATCH.id,
      file: lockPath,
      message: result.lockHash
        ? `Spec 해시 불일치: lock(${result.lockHash.slice(0, 8)}...) != current(${result.currentHash.slice(0, 8)}...)`
        : "spec.lock.json 파일이 없습니다",
      suggestion: "bunx mandu spec-upsert를 실행하여 변경사항을 반영하세요",
    };
  }

  return null;
}

// Rule 2: Generated file manual edit detection
export async function checkGeneratedManualEdit(
  rootDir: string,
  generatedMap: GeneratedMap
): Promise<GuardViolation[]> {
  const violations: GuardViolation[] = [];

  for (const [filePath, meta] of Object.entries(generatedMap.files)) {
    const fullPath = path.join(rootDir, filePath);
    const content = await readFileContent(fullPath);

    if (!content) continue;

    // Check if the "DO NOT EDIT" comment was removed or modified
    if (!content.includes("Generated by Mandu - DO NOT EDIT DIRECTLY")) {
      violations.push({
        ruleId: GUARD_RULES.GENERATED_MANUAL_EDIT.id,
        file: filePath,
        message: `generated 파일이 수동으로 변경된 것으로 보입니다 (routeId: ${meta.routeId})`,
        suggestion: "bunx mandu generate를 실행하여 파일을 재생성하세요",
      });
    }
  }

  return violations;
}

// Rule 3: Non-generated importing generated
export async function checkInvalidGeneratedImport(
  rootDir: string
): Promise<GuardViolation[]> {
  const violations: GuardViolation[] = [];

  // Scan non-generated source files
  const sourceDirs = [
    path.join(rootDir, "packages"),
    path.join(rootDir, "apps/server"),
    path.join(rootDir, "apps/web"),
  ];

  for (const sourceDir of sourceDirs) {
    const files = await scanTsFiles(sourceDir);

    for (const file of files) {
      // Skip generated directories
      if (file.includes("/generated/") || file.includes("\\generated\\")) {
        continue;
      }

      const content = await readFileContent(file);
      if (!content) continue;

      // Check for imports from generated directories
      const importRegex = /import\s+.*from\s+['"](.*generated.*)['"]/g;
      let match;

      while ((match = importRegex.exec(content)) !== null) {
        const relativePath = path.relative(rootDir, file);
        violations.push({
          ruleId: GUARD_RULES.INVALID_GENERATED_IMPORT.id,
          file: relativePath,
          message: `generated 파일 직접 import 금지: ${match[1]}`,
          suggestion:
            "generated 파일을 직접 import하지 말고, 런타임 레지스트리를 통해 접근하세요",
        });
      }
    }
  }

  return violations;
}

// Rule 4: Forbidden imports in generated files
export async function checkForbiddenImportsInGenerated(
  rootDir: string,
  generatedMap: GeneratedMap
): Promise<GuardViolation[]> {
  const violations: GuardViolation[] = [];

  for (const [filePath] of Object.entries(generatedMap.files)) {
    const fullPath = path.join(rootDir, filePath);
    const content = await readFileContent(fullPath);

    if (!content) continue;

    for (const forbidden of FORBIDDEN_IMPORTS) {
      const importRegex = new RegExp(
        `import\\s+.*from\\s+['"]${forbidden}['"]|require\\s*\\(\\s*['"]${forbidden}['"]\\s*\\)`,
        "g"
      );

      if (importRegex.test(content)) {
        violations.push({
          ruleId: GUARD_RULES.FORBIDDEN_IMPORT_IN_GENERATED.id,
          file: filePath,
          message: `generated 파일에서 금지된 모듈 '${forbidden}' import 감지`,
          suggestion: `'${forbidden}' 모듈 사용이 필요하면 slot 로직에서 처리하세요`,
        });
      }
    }
  }

  return violations;
}

async function scanTsFiles(dir: string): Promise<string[]> {
  const files: string[] = [];

  try {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        if (entry.name !== "node_modules" && entry.name !== "dist") {
          const subFiles = await scanTsFiles(fullPath);
          files.push(...subFiles);
        }
      } else if (entry.isFile() && (entry.name.endsWith(".ts") || entry.name.endsWith(".tsx"))) {
        files.push(fullPath);
      }
    }
  } catch {
    // Directory doesn't exist or can't be read
  }

  return files;
}

export async function runGuardCheck(
  manifest: RoutesManifest,
  rootDir: string
): Promise<GuardCheckResult> {
  const violations: GuardViolation[] = [];

  const lockPath = path.join(rootDir, "spec/spec.lock.json");
  const mapPath = path.join(rootDir, "packages/core/map/generated.map.json");

  // Rule 1
  const hashViolation = await checkSpecHashMismatch(manifest, lockPath);
  if (hashViolation) {
    violations.push(hashViolation);
  }

  // Load generated map for other checks
  let generatedMap: GeneratedMap | null = null;
  if (await fileExists(mapPath)) {
    try {
      const mapContent = await Bun.file(mapPath).text();
      generatedMap = JSON.parse(mapContent);
    } catch {
      // Map file corrupted or missing
    }
  }

  if (generatedMap) {
    // Rule 2
    const editViolations = await checkGeneratedManualEdit(rootDir, generatedMap);
    violations.push(...editViolations);

    // Rule 4
    const forbiddenViolations = await checkForbiddenImportsInGenerated(rootDir, generatedMap);
    violations.push(...forbiddenViolations);
  }

  // Rule 3
  const importViolations = await checkInvalidGeneratedImport(rootDir);
  violations.push(...importViolations);

  return {
    passed: violations.length === 0,
    violations,
  };
}
