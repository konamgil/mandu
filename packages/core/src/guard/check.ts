import { GUARD_RULES, FORBIDDEN_IMPORTS, type GuardViolation } from "./rules";
import { verifyLock, computeHash } from "../spec/lock";
import { runContractGuardCheck } from "./contract-guard";
import { validateSlotContent } from "../slot/validator";
import type { RoutesManifest } from "../spec/schema";
import type { GeneratedMap } from "../generator/generate";
import { loadManduConfig, type GuardRuleSeverity } from "../config";
import path from "path";
import fs from "fs/promises";

export interface GuardCheckResult {
  passed: boolean;
  violations: GuardViolation[];
}

function normalizeSeverity(level: GuardRuleSeverity): "error" | "warning" | "off" {
  if (level === "warn") return "warning";
  return level;
}

function applyRuleSeverity(
  violations: GuardViolation[],
  config: { rules?: Record<string, GuardRuleSeverity>; contractRequired?: GuardRuleSeverity }
): GuardViolation[] {
  const resolved: GuardViolation[] = [];
  const ruleOverrides = config.rules ?? {};

  for (const violation of violations) {
    let override = ruleOverrides[violation.ruleId];
    if (violation.ruleId === "CONTRACT_MISSING" && config.contractRequired) {
      override = config.contractRequired;
    }

    const baseSeverity = violation.severity ?? GUARD_RULES[violation.ruleId]?.severity ?? "error";
    const finalSeverity = override ? normalizeSeverity(override) : baseSeverity;

    if (finalSeverity === "off") continue;

    resolved.push({ ...violation, severity: finalSeverity });
  }

  return resolved;
}

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

async function readFileContent(filePath: string): Promise<string | null> {
  try {
    return await Bun.file(filePath).text();
  } catch {
    return null;
  }
}

// Rule 1: Spec hash mismatch
export async function checkSpecHashMismatch(
  manifest: RoutesManifest,
  lockPath: string
): Promise<GuardViolation | null> {
  const result = await verifyLock(lockPath, manifest);

  if (!result.valid) {
    return {
      ruleId: GUARD_RULES.SPEC_HASH_MISMATCH.id,
      file: lockPath,
      message: result.lockHash
        ? `Spec 해시 불일치: lock(${result.lockHash.slice(0, 8)}...) != current(${result.currentHash.slice(0, 8)}...)`
        : "spec.lock.json 파일이 없습니다",
      suggestion: "bunx mandu spec-upsert를 실행하여 변경사항을 반영하세요",
    };
  }

  return null;
}

// Rule 2: Generated file manual edit detection
export async function checkGeneratedManualEdit(
  rootDir: string,
  generatedMap: GeneratedMap
): Promise<GuardViolation[]> {
  const violations: GuardViolation[] = [];

  for (const [filePath, meta] of Object.entries(generatedMap.files)) {
    const fullPath = path.join(rootDir, filePath);
    const content = await readFileContent(fullPath);

    if (!content) continue;

    // Check if the "DO NOT EDIT" comment was removed or modified
    if (!content.includes("Generated by Mandu - DO NOT EDIT DIRECTLY")) {
      violations.push({
        ruleId: GUARD_RULES.GENERATED_MANUAL_EDIT.id,
        file: filePath,
        message: `generated 파일이 수동으로 변경된 것으로 보입니다 (routeId: ${meta.routeId})`,
        suggestion: "bunx mandu generate를 실행하여 파일을 재생성하세요",
      });
    }
  }

  return violations;
}

// Rule 3: Non-generated importing generated
export async function checkInvalidGeneratedImport(
  rootDir: string
): Promise<GuardViolation[]> {
  const violations: GuardViolation[] = [];

  // Scan non-generated source files
  const sourceDirs = [
    path.join(rootDir, "packages"),
    path.join(rootDir, "apps/server"),
    path.join(rootDir, "apps/web"),
  ];

  for (const sourceDir of sourceDirs) {
    const files = await scanTsFiles(sourceDir);

    for (const file of files) {
      // Skip generated directories
      if (file.includes("/generated/") || file.includes("\\generated\\")) {
        continue;
      }

      const content = await readFileContent(file);
      if (!content) continue;

      // Check for imports from generated directories
      const importRegex = /import\s+.*from\s+['"](.*generated.*)['"]/g;
      let match;

      while ((match = importRegex.exec(content)) !== null) {
        const relativePath = path.relative(rootDir, file);
        violations.push({
          ruleId: GUARD_RULES.INVALID_GENERATED_IMPORT.id,
          file: relativePath,
          message: `generated 파일 직접 import 금지: ${match[1]}`,
          suggestion:
            "generated 파일을 직접 import하지 말고, 런타임 레지스트리를 통해 접근하세요",
        });
      }
    }
  }

  return violations;
}

// Rule 5: Slot file existence check
export async function checkSlotFileExists(
  manifest: RoutesManifest,
  rootDir: string
): Promise<GuardViolation[]> {
  const violations: GuardViolation[] = [];

  for (const route of manifest.routes) {
    if (route.slotModule) {
      const slotPath = path.join(rootDir, route.slotModule);
      const exists = await fileExists(slotPath);

      if (!exists) {
        violations.push({
          ruleId: GUARD_RULES.SLOT_NOT_FOUND.id,
          file: route.slotModule,
          message: `Slot 파일을 찾을 수 없습니다 (routeId: ${route.id})`,
          suggestion: "bunx mandu generate를 실행하여 slot 파일을 생성하세요",
        });
      }
    }
  }

  return violations;
}

// Rule 6: Slot content validation (신규)
export async function checkSlotContentValidation(
  manifest: RoutesManifest,
  rootDir: string
): Promise<GuardViolation[]> {
  const violations: GuardViolation[] = [];

  for (const route of manifest.routes) {
    if (!route.slotModule) continue;

    const slotPath = path.join(rootDir, route.slotModule);
    const content = await readFileContent(slotPath);

    if (!content) continue; // File doesn't exist, handled by checkSlotFileExists

    const validationResult = validateSlotContent(content);

    // Convert slot validation issues to guard violations
    for (const issue of validationResult.issues) {
      if (issue.severity === "error") {
        // Map slot issue codes to guard rule IDs
        let ruleId = "SLOT_VALIDATION_ERROR";
        if (issue.code === "MISSING_DEFAULT_EXPORT") {
          ruleId = GUARD_RULES.SLOT_MISSING_DEFAULT_EXPORT?.id ?? "SLOT_MISSING_DEFAULT_EXPORT";
        } else if (issue.code === "NO_RESPONSE_PATTERN" || issue.code === "INVALID_HANDLER_RETURN") {
          ruleId = GUARD_RULES.SLOT_INVALID_RETURN?.id ?? "SLOT_INVALID_RETURN";
        } else if (issue.code === "MISSING_FILLING_PATTERN") {
          ruleId = GUARD_RULES.SLOT_MISSING_FILLING_PATTERN?.id ?? "SLOT_MISSING_FILLING_PATTERN";
        } else if (issue.code === "ZOD_DIRECT_IMPORT") {
          ruleId = GUARD_RULES.SLOT_ZOD_DIRECT_IMPORT?.id ?? "SLOT_ZOD_DIRECT_IMPORT";
        }

        violations.push({
          ruleId,
          file: route.slotModule,
          message: `[${route.id}] ${issue.message}`,
          suggestion: issue.suggestion,
          line: issue.line,
          severity: issue.severity,
        });
      }
    }
  }

  return violations;
}

// Rule: Island-First Integrity
export async function checkIslandFirstIntegrity(
  manifest: RoutesManifest,
  rootDir: string
): Promise<GuardViolation[]> {
  const violations: GuardViolation[] = [];

  for (const route of manifest.routes) {
    if (route.kind !== "page" || !route.clientModule) continue;

    // 1. clientModule 파일 존재 여부
    const clientPath = path.join(rootDir, route.clientModule);
    if (!(await fileExists(clientPath))) {
      violations.push({
        ruleId: "CLIENT_MODULE_NOT_FOUND",
        file: route.clientModule,
        message: `clientModule 파일을 찾을 수 없습니다 (routeId: ${route.id})`,
        suggestion: "clientModule 경로를 확인하거나 파일을 생성하세요",
      });
      continue;
    }

    // 2. componentModule이 island을 import하는지 확인
    if (route.componentModule) {
      const componentPath = path.join(rootDir, route.componentModule);
      const content = await readFileContent(componentPath);
      if (content && !content.includes("islandModule") && !content.includes("Island-First")) {
        violations.push({
          ruleId: "ISLAND_FIRST_INTEGRITY",
          file: route.componentModule,
          message: `componentModule이 island을 import하지 않습니다 (routeId: ${route.id})`,
          suggestion: "mandu generate를 실행하여 Island-First 템플릿으로 재생성하세요",
        });
      }
    }
  }

  return violations;
}

// Rule 4: Forbidden imports in generated files
export async function checkForbiddenImportsInGenerated(
  rootDir: string,
  generatedMap: GeneratedMap
): Promise<GuardViolation[]> {
  const violations: GuardViolation[] = [];

  for (const [filePath] of Object.entries(generatedMap.files)) {
    const fullPath = path.join(rootDir, filePath);
    const content = await readFileContent(fullPath);

    if (!content) continue;

    for (const forbidden of FORBIDDEN_IMPORTS) {
      const importRegex = new RegExp(
        `import\\s+.*from\\s+['"]${forbidden}['"]|require\\s*\\(\\s*['"]${forbidden}['"]\\s*\\)`,
        "g"
      );

      if (importRegex.test(content)) {
        violations.push({
          ruleId: GUARD_RULES.FORBIDDEN_IMPORT_IN_GENERATED.id,
          file: filePath,
          message: `generated 파일에서 금지된 모듈 '${forbidden}' import 감지`,
          suggestion: `'${forbidden}' 모듈 사용이 필요하면 slot 로직에서 처리하세요`,
        });
      }
    }
  }

  return violations;
}

async function scanTsFiles(dir: string): Promise<string[]> {
  const files: string[] = [];

  try {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        if (entry.name !== "node_modules" && entry.name !== "dist") {
          const subFiles = await scanTsFiles(fullPath);
          files.push(...subFiles);
        }
      } else if (entry.isFile() && (entry.name.endsWith(".ts") || entry.name.endsWith(".tsx"))) {
        files.push(fullPath);
      }
    }
  } catch {
    // Directory doesn't exist or can't be read
  }

  return files;
}

// Rule: spec/ directory naming convention scan
export async function checkSpecDirNaming(
  rootDir: string
): Promise<GuardViolation[]> {
  const violations: GuardViolation[] = [];

  // Check spec/slots/ — only .slot.ts allowed
  const slotsDir = path.join(rootDir, "spec/slots");
  try {
    const files = await fs.readdir(slotsDir);
    for (const file of files) {
      if (file.endsWith(".ts") && !file.endsWith(".slot.ts")) {
        violations.push({
          ruleId: GUARD_RULES.SLOT_DIR_INVALID_FILE.id,
          file: `spec/slots/${file}`,
          message: `spec/slots/에 .slot.ts가 아닌 파일: ${file}`,
          suggestion: `.slot.ts로 이름을 바꾸거나, 이 파일이 client slot이면 apps/web/components/로 이동하세요`,
        });
      }
    }
  } catch {}

  // Check spec/contracts/ — only .contract.ts allowed
  const contractsDir = path.join(rootDir, "spec/contracts");
  try {
    const files = await fs.readdir(contractsDir);
    for (const file of files) {
      if (file.endsWith(".ts") && !file.endsWith(".contract.ts")) {
        violations.push({
          ruleId: GUARD_RULES.CONTRACT_DIR_INVALID_FILE.id,
          file: `spec/contracts/${file}`,
          message: `spec/contracts/에 .contract.ts가 아닌 파일: ${file}`,
          suggestion: `.contract.ts로 이름을 바꾸세요`,
        });
      }
    }
  } catch {}

  return violations;
}

export async function runGuardCheck(
  manifest: RoutesManifest,
  rootDir: string
): Promise<GuardCheckResult> {
  const violations: GuardViolation[] = [];
  const config = await loadManduConfig(rootDir);

  const lockPath = path.join(rootDir, "spec/spec.lock.json");
  const mapPath = path.join(rootDir, "packages/core/map/generated.map.json");

  // Rule 1
  const hashViolation = await checkSpecHashMismatch(manifest, lockPath);
  if (hashViolation) {
    violations.push(hashViolation);
  }

  // Load generated map for other checks
  let generatedMap: GeneratedMap | null = null;
  if (await fileExists(mapPath)) {
    try {
      const mapContent = await Bun.file(mapPath).text();
      generatedMap = JSON.parse(mapContent);
    } catch {
      // Map file corrupted or missing
    }
  }

  if (generatedMap) {
    // Rule 2
    const editViolations = await checkGeneratedManualEdit(rootDir, generatedMap);
    violations.push(...editViolations);

    // Rule 4
    const forbiddenViolations = await checkForbiddenImportsInGenerated(rootDir, generatedMap);
    violations.push(...forbiddenViolations);
  }

  // Rule 3
  const importViolations = await checkInvalidGeneratedImport(rootDir);
  violations.push(...importViolations);

  // Rule 5: Slot file existence
  const slotViolations = await checkSlotFileExists(manifest, rootDir);
  violations.push(...slotViolations);

  // Rule 6: Slot content validation (신규 - 강화된 검증)
  const slotContentViolations = await checkSlotContentValidation(manifest, rootDir);
  violations.push(...slotContentViolations);

  // Rule 7-10: Contract-related checks
  const contractViolations = await runContractGuardCheck(manifest, rootDir);
  violations.push(...contractViolations);

  // Rule: Island-First Integrity
  const islandViolations = await checkIslandFirstIntegrity(manifest, rootDir);
  violations.push(...islandViolations);

  // Rule: spec/ directory naming convention
  const specDirViolations = await checkSpecDirNaming(rootDir);
  violations.push(...specDirViolations);

  const resolvedViolations = applyRuleSeverity(violations, config.guard ?? {});
  const passed = resolvedViolations.every((v) => v.severity !== "error");

  return {
    passed,
    violations: resolvedViolations,
  };
}
