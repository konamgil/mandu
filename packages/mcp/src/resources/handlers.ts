import type { Resource } from "@modelcontextprotocol/sdk/types.js";
import {
  loadManifest,
  getTransactionStatus,
  type GeneratedMap,
  type SpecLock,
} from "@mandujs/core";
import { getProjectPaths, readJsonFile } from "../utils/project.js";
import path from "path";

export const resourceDefinitions: Resource[] = [
  {
    uri: "mandu://spec/manifest",
    name: "Routes Manifest",
    description: "Current routes.manifest.json content",
    mimeType: "application/json",
  },
  {
    uri: "mandu://spec/lock",
    name: "Spec Lock",
    description: "Current spec.lock.json with hash verification",
    mimeType: "application/json",
  },
  {
    uri: "mandu://generated/map",
    name: "Generated Map",
    description: "Map of generated files to their source routes",
    mimeType: "application/json",
  },
  {
    uri: "mandu://transaction/active",
    name: "Active Transaction",
    description: "Current active transaction information",
    mimeType: "application/json",
  },
  {
    uri: "mandu://slots/{routeId}",
    name: "Route Slot",
    description: "Slot file content for a specific route",
    mimeType: "text/typescript",
  },
];

type ResourceHandler = (params: Record<string, string>) => Promise<unknown>;

export function resourceHandlers(
  projectRoot: string
): Record<string, ResourceHandler> {
  const paths = getProjectPaths(projectRoot);

  return {
    "mandu://spec/manifest": async () => {
      const result = await loadManifest(paths.manifestPath);
      if (!result.success || !result.data) {
        return {
          error: "Failed to load manifest",
          details: result.errors,
        };
      }

      return {
        version: result.data.version,
        routeCount: result.data.routes.length,
        routes: result.data.routes,
      };
    },

    "mandu://spec/lock": async () => {
      const lock = await readJsonFile<SpecLock>(paths.lockPath);
      if (!lock) {
        return {
          exists: false,
          message: "spec.lock.json not found",
        };
      }

      return {
        exists: true,
        routesHash: lock.routesHash,
        updatedAt: lock.updatedAt,
      };
    },

    "mandu://generated/map": async () => {
      const generatedMap = await readJsonFile<GeneratedMap>(paths.generatedMapPath);
      if (!generatedMap) {
        return {
          exists: false,
          message: "generated.map.json not found. Run mandu generate first.",
        };
      }

      return {
        exists: true,
        version: generatedMap.version,
        generatedAt: generatedMap.generatedAt,
        specSource: generatedMap.specSource,
        fileCount: Object.keys(generatedMap.files).length,
        files: generatedMap.files,
        frameworkPaths: generatedMap.frameworkPaths,
      };
    },

    "mandu://transaction/active": async () => {
      const { state, change } = await getTransactionStatus(projectRoot);

      if (!state.active) {
        return {
          hasActive: false,
          message: "No active transaction",
        };
      }

      return {
        hasActive: true,
        changeId: state.changeId,
        snapshotId: state.snapshotId,
        change: change
          ? {
              id: change.id,
              message: change.message,
              status: change.status,
              createdAt: change.createdAt,
              autoGenerated: change.autoGenerated,
            }
          : null,
      };
    },

    "mandu://slots/{routeId}": async (params: Record<string, string>) => {
      const { routeId } = params;

      if (!routeId) {
        return { error: "routeId parameter is required" };
      }

      // Load manifest to find the route
      const result = await loadManifest(paths.manifestPath);
      if (!result.success || !result.data) {
        return { error: result.errors };
      }

      const route = result.data.routes.find((r) => r.id === routeId);
      if (!route) {
        return { error: `Route not found: ${routeId}` };
      }

      if (!route.slotModule) {
        return {
          error: `Route '${routeId}' does not have a slotModule`,
        };
      }

      const slotPath = path.join(projectRoot, route.slotModule);
      const file = Bun.file(slotPath);

      if (!(await file.exists())) {
        return {
          exists: false,
          slotModule: route.slotModule,
          message: "Slot file does not exist",
        };
      }

      const content = await file.text();
      return {
        exists: true,
        slotModule: route.slotModule,
        routeId,
        kind: route.kind,
        pattern: route.pattern,
        content,
      };
    },
  };
}
