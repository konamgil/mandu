# RFC-001: Mandu Philosophy Evolution

## From "Guarding AI" to "Guiding AI"

> 만두 장인이 견습생을 가르치듯, 프레임워크가 AI를 이끈다

---

## TL;DR (1분 요약)

### 문제
```
현재 Mandu: AI가 실수 → Guard가 "안 돼!" → 개발자가 수정
           (수동적, 방어적, AI는 학습 못함)
```

### 제안
```
새로운 Mandu: AI가 의도 전달 → Framework가 "이렇게 해봐" → AI가 올바르게 구현
             (능동적, 협력적, AI가 맥락 이해)
```

### 핵심 기능 4가지

| 기능 | 한 줄 설명 |
|------|-----------|
| **Self-Healing Guard** | 위반 감지 + 자동 수정 제안 |
| **Architecture Negotiation** | AI와 프레임워크가 구조를 "협상" |
| **Semantic Slots** | 슬롯에 목적과 제약을 선언 |
| **Decision Memory** | 과거 결정을 기억해 일관성 유지 |

### 왜 중요한가?

```
"왜 Next.js 대신 Mandu?" 에 대한 진짜 답:
→ "AI와 협업하도록 설계된 유일한 프레임워크"
```

---

## 목차

1. [동기](#1-동기)
2. [현재 상태 분석](#2-현재-상태-분석)
3. [새로운 방향](#3-새로운-방향)
4. [구체적 기능 제안](#4-구체적-기능-제안)
5. [실제 사용 시나리오](#5-실제-사용-시나리오)
6. [구현 로드맵](#6-구현-로드맵)
7. [하위 호환성](#7-하위-호환성)
8. [대안 검토](#8-대안-검토)
9. [열린 질문](#9-열린-질문)

---

## 1. 동기

### 1.1 AI 코딩 시대의 현실

```
┌─────────────────────────────────────────────────────────────┐
│                    AI 코딩의 진화                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  2023 ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░  코드 자동완성        │
│  2024 ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░  파일 단위 생성  │
│  2025 ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░  기능 구현  │
│  2026 ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░  ???    │
│                                                             │
│  AI가 점점 더 많은 코드를 작성하고 있다                        │
│  그런데 프레임워크는 아직도 "인간만" 생각한다                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 기존 프레임워크의 암묵적 가정

| 가정 | AI 시대의 현실 |
|------|---------------|
| 개발자가 아키텍처를 이해한다 | AI는 컨텍스트가 제한적 |
| 개발자가 일관성을 유지한다 | AI는 매 요청마다 새로 시작 |
| 개발자가 과거 결정을 기억한다 | AI는 세션 간 기억이 없음 |
| 개발자가 "왜"를 안다 | AI는 규칙만 알고 이유를 모름 |

### 1.3 Mandu의 현재 접근법과 한계

```
┌──────────────────────────────────────────────────────────────────┐
│                     현재 Guard의 동작                             │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│   AI Agent                        Mandu Guard                    │
│      │                                │                          │
│      │  "shared/에서 client/ import"  │                          │
│      │ ─────────────────────────────> │                          │
│      │                                │                          │
│      │        "❌ 위반!"               │                          │
│      │ <───────────────────────────── │                          │
│      │                                │                          │
│      │  "왜요? 어떻게 고쳐요?"         │                          │
│      │ ─────────────────────────────> │                          │
│      │                                │                          │
│      │        "..."  (응답 없음)       │                          │
│      │ <───────────────────────────── │                          │
│      │                                │                          │
│      ▼                                                           │
│   😕 AI는 같은 실수를 반복                                        │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

**문제점:**
- 🚫 "안 돼"만 말하고 "왜"를 설명하지 않음
- 🚫 "어떻게 고쳐야 하는지" 알려주지 않음
- 🚫 AI가 학습할 수 없음 → 같은 실수 반복
- 🚫 수동적/방어적 접근

---

## 2. 현재 상태 분석

### 2.1 Mandu의 기술적 강점

```
┌─────────────────────────────────────────────────────────────┐
│                    Mandu v0.9.x 기능                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ✅ FS Routes          파일 시스템 기반 라우팅               │
│  ✅ Guard System       아키텍처 규칙 검사                    │
│  ✅ Slot System        비즈니스 로직 격리                    │
│  ✅ MCP Server         AI 에이전트 통합 (25+ 도구)          │
│  ✅ Island Hydration   선택적 클라이언트 JS                  │
│  ✅ Contract API       타입 안전 API 계약                    │
│  ✅ SEO Module         메타데이터, sitemap, JSON-LD         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 차용한 것들 (솔직한 인정)

```
┌────────────────────────────────────────────────────────────────┐
│                    영감을 받은 프레임워크들                      │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│   Next.js ─────────►  FS Routes, Layout, Metadata API         │
│                                                                │
│   Astro ──────────►  Island Hydration, Content Layer          │
│                                                                │
│   Qwik ───────────►  Resumability (로드맵)                    │
│                                                                │
│   Phoenix ────────►  Channel 패턴 (로드맵)                    │
│                                                                │
│   Elysia ─────────►  Contract API, DNA 패턴                   │
│                                                                │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│   🤔 "좋은 것들 조합"만으로는 차별화가 약하다                    │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### 2.3 핵심 질문

> **"왜 Next.js/Remix/Astro 대신 Mandu를 써야 하는가?"**

현재 답변:
- "AI 에이전트 친화적" → 구체적으로 뭐가 다른가?
- "Guard가 아키텍처를 지킨다" → ESLint도 그렇게 한다

**진정한 차별화가 필요하다.**

---

## 3. 새로운 방향

### 3.1 핵심 철학 전환

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│                    패러다임 전환                                 │
│                                                                 │
│     "AI가 깨뜨릴 수 없는 아키텍처"                               │
│                     │                                           │
│                     ▼                                           │
│     "AI를 올바른 방향으로 이끄는 아키텍처"                        │
│                                                                 │
│  ┌─────────────┐              ┌─────────────┐                   │
│  │   Guard     │    ────►    │    Guide    │                   │
│  │   (방어)    │              │   (안내)    │                   │
│  └─────────────┘              └─────────────┘                   │
│                                                                 │
│  감시자 → 멘토                                                   │
│  "안 돼" → "이렇게 해봐"                                         │
│  사후 검사 → 사전 안내 + 사후 교정                                │
│  경고 → 해결책                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 새로운 비유: 만두 장인

**기존 비유:**
```
🥟 만두 껍질(Guard)이 속(코드)을 감싸 모양을 유지한다
   → 껍질 = 감옥, 속 = 갇힌 존재
```

**새로운 비유:**
```
👨‍🍳 만두 장인(Framework)이 견습생(AI)에게 기술을 전수한다

   장인: "속을 이렇게 넣어야 터지지 않아"
   장인: "이 반죽은 이 정도 두께가 좋아"
   장인: "자, 내가 시범 보여줄게"

   → 실수하면 즉시 교정하고 이유를 설명
   → 견습생은 점점 실력이 늘어남
```

### 3.3 프레임워크의 재정의

```
┌───────────────────────────────────────────────────────────────┐
│                                                               │
│   기존 프레임워크                    새로운 Mandu              │
│                                                               │
│   ┌─────────────┐                   ┌─────────────┐           │
│   │    Tool     │                   │ Collaborator│           │
│   │   (도구)    │                   │  (협업자)   │           │
│   └─────────────┘                   └─────────────┘           │
│         │                                 │                   │
│         ▼                                 ▼                   │
│   개발자가 사용하는              AI와 함께 코드를 만드는       │
│   수동적 존재                    능동적 존재                   │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

### 3.4 새로운 슬로건

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│           "AI 시대의 아키텍처 멘토"                          │
│                                                             │
│     The Architecture Mentor for the AI Era                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 4. 구체적 기능 제안

### 4.1 Self-Healing Guard (자가 치유 가드)

**개념:** 위반 감지 + 자동 수정 제안 + 맥락 설명

```
┌─────────────────────────────────────────────────────────────────┐
│                  Self-Healing Guard 동작                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   AI Agent                          Mandu Guide                 │
│      │                                  │                       │
│      │  "shared/에서 client/ import"    │                       │
│      │ ───────────────────────────────> │                       │
│      │                                  │                       │
│      │    ┌──────────────────────────┐  │                       │
│      │    │ 🔍 위반 감지              │  │                       │
│      │    │ 💡 해결책 2개 제안        │  │                       │
│      │    │ 📚 왜 잘못인지 설명       │  │                       │
│      │    │ 🔧 자동 수정 옵션         │  │                       │
│      │    └──────────────────────────┘  │                       │
│      │ <─────────────────────────────── │                       │
│      │                                  │                       │
│      ▼                                  │                       │
│   😊 AI가 이해하고 올바르게 수정                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**API 설계:**

```typescript
// 현재
const violations = await guard.check();
// → ["❌ Invalid import: shared/utils → client/components"]

// 제안
const result = await guard.checkWithHealing();
// → {
//   violations: [{
//     type: "invalid-import",
//     file: "src/shared/utils/format.ts",
//     line: 5,
//     message: "shared 레이어에서 client 레이어 import 불가",
//     severity: "error"
//   }],
//
//   suggestions: [{
//     violation: 0,
//     options: [
//       {
//         label: "코드를 client/shared로 이동",
//         explanation: "이 유틸은 클라이언트 전용이므로 client/shared에 위치해야 합니다",
//         autoFix: async () => moveFile(...)
//       },
//       {
//         label: "dynamic import로 변경",
//         explanation: "런타임에만 필요하다면 dynamic import로 레이어 분리 가능",
//         autoFix: async () => convertToDynamicImport(...)
//       }
//     ]
//   }],
//
//   context: {
//     layerHierarchy: "app → pages → widgets → features → entities → shared",
//     rule: "상위 레이어는 하위 레이어만 import 가능",
//     documentation: "https://mandu.dev/docs/architecture/layers"
//   }
// }
```

**MCP 도구 확장:**

```typescript
// 새로운 MCP 도구들
mandu_guard_heal({
  file: "src/shared/utils/format.ts",
  autoFix: true
})

mandu_guard_explain({
  rule: "layer-import",
  context: "shared → client"
})
```

---

### 4.2 Architecture Negotiation Protocol (아키텍처 협상)

**개념:** AI가 기능 구현 전에 프레임워크와 "협상"

```
┌─────────────────────────────────────────────────────────────────┐
│                Architecture Negotiation 흐름                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   AI Agent                          Mandu Framework             │
│      │                                  │                       │
│      │  ① "사용자 인증 기능 추가하고 싶어"                       │
│      │ ───────────────────────────────> │                       │
│      │                                  │  ┌─────────────────┐  │
│      │                                  │  │ 아키텍처 분석   │  │
│      │                                  │  │ 기존 패턴 확인  │  │
│      │                                  │  │ 최적 구조 계산  │  │
│      │                                  │  └─────────────────┘  │
│      │  ② "이렇게 구조화하는 게 좋겠어"  │                       │
│      │ <─────────────────────────────── │                       │
│      │     [구조 제안 + 이유 + 경고]     │                       │
│      │                                  │                       │
│      │  ③ "좋아, 그렇게 할게"           │                       │
│      │ ───────────────────────────────> │                       │
│      │                                  │                       │
│      │  ④ [scaffold 생성]              │                       │
│      │ <─────────────────────────────── │                       │
│      │                                  │                       │
│      ▼                                  │                       │
│   AI가 scaffold 내 slot을 채움                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**API 설계:**

```typescript
const plan = await mandu.negotiate({
  intent: "사용자 인증 기능 추가",
  requirements: ["JWT 기반", "리프레시 토큰", "OAuth 소셜 로그인"],
  constraints: ["기존 User 모델 활용", "Redis 세션"]
});

// 응답:
// {
//   approved: true,
//   structure: {
//     "server/domain/auth/": {
//       purpose: "인증 도메인 로직",
//       files: ["jwt.service.ts", "oauth.service.ts"]
//     },
//     "server/application/auth/": {
//       purpose: "인증 유스케이스",
//       files: ["login.usecase.ts", "refresh.usecase.ts"]
//     },
//     "app/api/auth/": {
//       purpose: "인증 API 라우트",
//       files: ["login/route.ts", "oauth/[provider]/route.ts"]
//     }
//   },
//   slots: [
//     { path: "server/domain/auth/jwt.service.ts", purpose: "JWT 생성/검증" }
//   ],
//   warnings: ["User 모델에 refreshToken 필드 추가 필요"],
//   relatedDecisions: [{ id: "ADR-003", title: "인증 전략" }]
// }
```

---

### 4.3 Semantic Slots (의미론적 슬롯)

**개념:** 슬롯에 "목적"과 "제약"을 명시

```
┌─────────────────────────────────────────────────────────────────┐
│                    Semantic Slot 구조                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                    Slot Definition                       │   │
│   ├─────────────────────────────────────────────────────────┤   │
│   │                                                         │   │
│   │  📋 Purpose     "사용자 목록 조회 API"                   │   │
│   │                                                         │   │
│   │  ✅ Required    [입력 검증, 에러 처리, 페이지네이션]      │   │
│   │                                                         │   │
│   │  🚫 Forbidden   [DB 직접 쓰기, 외부 API, 민감 정보 로깅] │   │
│   │                                                         │   │
│   │  📦 Allowed     [server/domain/user/*, shared/utils/*]  │   │
│   │     Imports                                             │   │
│   │                                                         │   │
│   │  📏 Limits      maxLines: 50, maxComplexity: 10         │   │
│   │                                                         │   │
│   └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                    Implementation                        │   │
│   │                                                         │   │
│   │   AI가 제약 내에서 자유롭게 구현                          │   │
│   │   Guard가 실시간으로 제약 준수 여부 검사                   │   │
│   │                                                         │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**API 설계:**

```typescript
export default Mandu.filling()
  .purpose("사용자 목록 조회 API")
  .description("페이지네이션된 사용자 목록 반환. 관리자 전용.")

  .constraints({
    maxLines: 50,
    maxCyclomaticComplexity: 10,

    requiredPatterns: ["input-validation", "error-handling", "pagination"],
    forbiddenPatterns: ["direct-db-write", "external-api-call"],

    allowedImports: [
      "server/domain/user/*",
      "server/application/user/*",
      "shared/utils/*"
    ]
  })

  .contract({
    input: z.object({
      page: z.number().min(1).default(1),
      limit: z.number().max(100).default(20)
    }),
    output: z.object({
      users: z.array(UserSchema),
      total: z.number()
    })
  })

  .get(async (ctx) => {
    // AI가 제약 내에서 구현
  });
```

---

### 4.4 Architecture Decision Memory (아키텍처 결정 기억)

**개념:** 과거 결정을 저장하여 AI가 일관된 선택을 하도록 유도

```
┌─────────────────────────────────────────────────────────────────┐
│                  Decision Memory 구조                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   spec/                                                         │
│   ├── routes.manifest.json      # 기존                          │
│   ├── architecture.json         # 새로: AI용 압축 버전           │
│   └── decisions/                # 새로: 결정 히스토리            │
│       ├── ADR-001-framework.md                                  │
│       ├── ADR-002-database.md                                   │
│       └── ADR-003-auth.md                                       │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   AI가 "인증" 관련 작업 시:                                      │
│                                                                 │
│   ┌───────────────┐      ┌───────────────────────────────────┐ │
│   │   AI Agent    │ ───► │  mandu_get_decisions(["auth"])    │ │
│   └───────────────┘      └───────────────────────────────────┘ │
│                                    │                            │
│                                    ▼                            │
│                          ┌─────────────────────┐                │
│                          │  ADR-003 반환       │                │
│                          │  - JWT 사용         │                │
│                          │  - Redis 세션       │                │
│                          │  - 위치 규칙        │                │
│                          └─────────────────────┘                │
│                                    │                            │
│                                    ▼                            │
│                          AI가 기존 결정과 일관되게 구현           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. 실제 사용 시나리오

### 시나리오 1: 새 기능 추가

```
┌─────────────────────────────────────────────────────────────────┐
│          시나리오: "결제 기능 추가해줘"                           │
├─────────────────────────────────────────────────────────────────┤

👤 User: "결제 기능 추가해줘. Stripe 연동으로."

🤖 AI Agent:
   │
   ├─► mandu_get_decisions(["payment", "external-api"])
   │   → "외부 API는 server/infra/에 위치" (ADR-005)
   │
   ├─► mandu_negotiate({
   │     intent: "Stripe 결제 연동",
   │     requirements: ["카드 결제", "웹훅 처리"]
   │   })
   │
   │   Framework 응답:
   │   ┌──────────────────────────────────────────────────┐
   │   │ ✅ 승인                                          │
   │   │                                                  │
   │   │ 📁 권장 구조:                                    │
   │   │   server/infra/payment/stripe.client.ts         │
   │   │   server/domain/payment/payment.service.ts      │
   │   │   server/application/payment/checkout.usecase.ts│
   │   │   app/api/payment/checkout/route.ts             │
   │   │   app/api/webhooks/stripe/route.ts              │
   │   │                                                  │
   │   │ ⚠️ 주의:                                        │
   │   │   - STRIPE_SECRET_KEY 환경변수 필요              │
   │   │   - 웹훅 서명 검증 필수                          │
   │   └──────────────────────────────────────────────────┘
   │
   ├─► scaffold 생성
   │
   └─► 각 slot 구현 (제약 내에서)

✅ 결과: 아키텍처와 일관된 결제 기능 완성
```

### 시나리오 2: 실수 교정

```
┌─────────────────────────────────────────────────────────────────┐
│          시나리오: AI가 잘못된 위치에 코드 작성                   │
├─────────────────────────────────────────────────────────────────┤

🤖 AI Agent: shared/utils/에 React 컴포넌트 작성

🛡️ Guard (실시간 감지):
   ┌──────────────────────────────────────────────────────┐
   │ ❌ 위반 감지                                         │
   │                                                      │
   │ 📍 파일: src/shared/utils/UserAvatar.tsx            │
   │ 📋 규칙: shared/ 레이어는 서버/클라이언트 공용       │
   │ 🔍 문제: React 컴포넌트는 클라이언트 전용            │
   │                                                      │
   │ 💡 제안:                                            │
   │   1. client/shared/ui/UserAvatar.tsx로 이동 (추천)  │
   │   2. 서버에서도 필요하면 RSC로 변환                  │
   │                                                      │
   │ 🔧 자동 수정: mandu_guard_heal --autoFix            │
   └──────────────────────────────────────────────────────┘

🤖 AI Agent: "아, 이해했어. 이동할게."
   │
   └─► mandu_guard_heal({ autoFix: true })

✅ 결과: 파일이 올바른 위치로 자동 이동
```

### 시나리오 3: 일관성 유지

```
┌─────────────────────────────────────────────────────────────────┐
│          시나리오: 새 개발자(AI)가 기존 패턴 모름                 │
├─────────────────────────────────────────────────────────────────┤

👤 User: "캐싱 기능 추가해줘"

🤖 AI Agent (첫 시도): Redis 직접 사용하려 함

🛡️ Guard:
   ┌──────────────────────────────────────────────────────┐
   │ ⚠️ 일관성 경고                                       │
   │                                                      │
   │ 📋 ADR-007에 따르면:                                 │
   │   "캐시는 server/infra/cache/를 통해 접근"           │
   │   "직접 Redis 클라이언트 사용 금지"                  │
   │                                                      │
   │ 📍 기존 패턴:                                        │
   │   import { cache } from 'server/infra/cache'        │
   │   await cache.get('key')                            │
   │                                                      │
   │ 💡 이 패턴을 따르면 나중에 캐시 백엔드 교체가 쉬워요  │
   └──────────────────────────────────────────────────────┘

🤖 AI Agent: "알겠어, 기존 패턴 따를게."

✅ 결과: 프로젝트 전체 일관성 유지
```

---

## 6. 구현 로드맵

```
┌─────────────────────────────────────────────────────────────────┐
│                      구현 로드맵                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Phase 1: Self-Healing Guard                    v0.10.x         │
│  ════════════════════════════════════════════                   │
│  │                                                              │
│  ├─ GuardResult 타입 확장 (suggestions, context)                │
│  ├─ 각 규칙에 explanation, autoFix 로직 추가                    │
│  ├─ MCP 도구: mandu_guard_heal, mandu_guard_explain            │
│  └─ 테스트 및 문서화                                            │
│                                                                 │
│                                                                 │
│  Phase 2: Semantic Slots                        v0.10.x         │
│  ════════════════════════════════════════════                   │
│  │                                                              │
│  ├─ Filling API 확장 (.purpose, .constraints)                   │
│  ├─ 슬롯 검증 로직 구현                                         │
│  ├─ Guard와 통합                                                │
│  └─ 테스트 및 문서화                                            │
│                                                                 │
│                                                                 │
│  Phase 3: Architecture Negotiation              v0.11.x         │
│  ════════════════════════════════════════════                   │
│  │                                                              │
│  ├─ Negotiation API 설계                                        │
│  ├─ 구조 분석 및 제안 로직                                      │
│  ├─ MCP 도구: mandu_negotiate                                   │
│  ├─ scaffold 생성기                                             │
│  └─ 테스트 및 문서화                                            │
│                                                                 │
│                                                                 │
│  Phase 4: Decision Memory                       v0.11.x         │
│  ════════════════════════════════════════════                   │
│  │                                                              │
│  ├─ ADR 형식 정의                                               │
│  ├─ architecture.json 스키마                                    │
│  ├─ 결정 조회/저장 API                                          │
│  ├─ 일관성 검사 로직                                            │
│  └─ MCP 도구 추가                                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. 하위 호환성

### 7.1 기존 API 100% 유지

```typescript
// ✅ 기존 코드 - 변경 없이 계속 동작
export default Mandu.filling()
  .get(async (ctx) => { ... });

// ✅ 새 기능 - 선택적 사용
export default Mandu.filling()
  .purpose("...")           // 선택
  .constraints({...})       // 선택
  .get(async (ctx) => { ... });
```

### 7.2 점진적 도입

```
Level 0: 기존 그대로 사용
Level 1: guard.checkWithHealing() 사용
Level 2: Semantic Slots 도입
Level 3: Architecture Negotiation 활용
Level 4: Decision Memory로 완전 통합
```

---

## 8. 대안 검토

### 8.1 왜 기존 린터가 아닌가?

| ESLint 등 | Mandu Guide |
|-----------|-------------|
| 정적 분석 | 동적 아키텍처 이해 |
| 일반적 규칙 | 프로젝트 맞춤 |
| 텍스트 경고 | 실행 가능한 해결책 |
| 인간 대상 | AI 대상 최적화 |

### 8.2 왜 프레임워크 내장인가?

- 아키텍처 정보에 깊은 접근 필요
- 런타임 정보 활용 가능
- 일관된 경험

### 8.3 왜 MCP 기반인가?

- 표준 프로토콜
- Claude, Cursor 등과 즉시 연동
- 확장 가능

---

## 9. 열린 질문

### 토론 필요

1. **자동 수정의 범위** - 얼마나 적극적으로?
2. **Semantic Slots 강제성** - 빌드 실패? 경고만?
3. **Decision Memory 저장 위치** - Git? 별도?
4. **성능 영향** - 실시간 검사 오버헤드?
5. **학습 곡선** - 너무 복잡하지 않은가?

---

## 결론

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   현재: AI가 코드 작성 → Guard가 막음 → 개발자가 수정           │
│                                                                 │
│   미래: AI가 의도 전달 → Framework가 안내 → AI가 올바르게 구현   │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Mandu는 "AI 시대의 아키텍처 멘토"가 될 수 있습니다.           │
│                                                                 │
│   • 진정한 차별화 달성                                          │
│   • AI 코딩 시대의 표준 제시                                    │
│   • 개발자와 AI 모두에게 가치 제공                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 피드백 요청

이 RFC에 대한 의견을 환영합니다:

- 전체적인 방향성에 동의하시나요?
- 우선순위 조정이 필요한 부분이 있나요?
- 놓친 중요한 고려사항이 있나요?
- 구현 시 예상되는 어려움이 있나요?

GitHub Discussion 또는 Issue로 피드백 부탁드립니다.

---

**작성자:** [Your Name]
**날짜:** 2026-02-04
**상태:** Draft (피드백 수집 중)
**버전:** 1.1
